<!doctype html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Test Preloader - NODS</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        background: #111;
        color: white;
      }

      /* Preloader Styles */
      .preloader_component {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        z-index: 9999;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 1;
        transition: opacity 0.8s ease;
      }

      .prealoader_cards {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 2rem;
        will-change: transform;
      }

      .prealoader_cards-logo {
        font-size: 3rem;
        font-weight: 900;
        letter-spacing: 0.2em;
        color: white;
        text-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      }

      .prealoader_cards-loading-count {
        font-size: 4rem;
        font-weight: 700;
        color: #fff;
        text-align: center;
        font-variant-numeric: tabular-nums;
        min-width: 200px;
        text-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      }

      .prealoader_cards-text {
        font-size: 1rem;
        color: rgba(255, 255, 255, 0.8);
        letter-spacing: 0.1em;
        text-transform: uppercase;
      }

      /* Page content */
      .content {
        padding: 100px 20px;
        max-width: 1200px;
        margin: 0 auto;
      }

      h1 {
        font-size: 3rem;
        margin-bottom: 2rem;
      }

      p {
        font-size: 1.2rem;
        line-height: 1.8;
        margin-bottom: 1rem;
        color: rgba(255, 255, 255, 0.8);
      }

      .reset-btn {
        margin-top: 2rem;
        padding: 1rem 2rem;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 1rem;
        font-weight: 600;
        transition: transform 0.2s;
      }

      .reset-btn:hover {
        transform: scale(1.05);
      }

      .reset-btn:active {
        transform: scale(0.95);
      }

      /* Simulated heavy resources */
      .hidden-images {
        display: none;
      }

      @media (max-width: 768px) {
        .prealoader_cards-loading-count {
          font-size: 3rem;
        }

        h1 {
          font-size: 2rem;
        }
      }
    </style>
  </head>
  <body>
    <!-- PRELOADER -->
    <div class="preloader_component">
      <div class="prealoader_cards">
        <div class="prealoader_cards-logo">NODS</div>
        <div class="prealoader_cards-loading-count">0%</div>
        <div class="prealoader_cards-text">Chargement en cours...</div>
      </div>
    </div>

    <!-- MAIN CONTENT -->
    <div class="content">
      <h1>‚ú® Test du Preloader</h1>

      <p>Si vous voyez cette page, le preloader a fonctionn√© !</p>

      <p>Le preloader ne s'affichera plus pendant 1 semaine (sauf si vous videz le cache).</p>

      <button class="reset-btn" onclick="resetPreloader()">
        üîÑ R√©initialiser et recharger (revoir le preloader)
      </button>

      <h2 style="margin-top: 3rem">üìù Instructions :</h2>
      <p>1. Le compteur devrait passer de 0% √† 100% au chargement</p>
      <p>2. Les cartes suivent le mouvement de votre souris</p>
      <p>3. Le preloader dispara√Æt une fois le chargement termin√©</p>
      <p>4. Cliquez sur le bouton ci-dessus pour revoir le preloader</p>
    </div>

    <!-- Simulated heavy resources to test loading -->
    <div class="hidden-images">
      <img src="https://picsum.photos/1920/1080?random=1" alt="" />
      <img src="https://picsum.photos/1920/1080?random=2" alt="" />
      <img src="https://picsum.photos/1920/1080?random=3" alt="" />
      <img src="https://picsum.photos/1920/1080?random=4" alt="" />
      <img src="https://picsum.photos/1920/1080?random=5" alt="" />
    </div>

    <!-- Include GSAP -->
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.4/dist/gsap.min.js"></script>

    <!-- Preloader Script (embedded version for testing) -->
    <script>
      function resetPreloader() {
        localStorage.removeItem('nods_first_visit');
        location.reload();
      }

      // Preloader logic
      const CACHE_KEY = 'nods_first_visit';
      const CACHE_DURATION = 7 * 24 * 60 * 60 * 1000; // 1 semaine

      const isFirstVisit = () => {
        const cachedVisit = localStorage.getItem(CACHE_KEY);
        if (!cachedVisit) return true;

        try {
          const visitData = JSON.parse(cachedVisit);
          const now = Date.now();
          if (now - visitData.timestamp < CACHE_DURATION) {
            return false;
          }
          localStorage.removeItem(CACHE_KEY);
          return true;
        } catch {
          localStorage.removeItem(CACHE_KEY);
          return true;
        }
      };

      const markVisitComplete = () => {
        const visitData = { timestamp: Date.now() };
        localStorage.setItem(CACHE_KEY, JSON.stringify(visitData));
      };

      const animateCounter = async (counterElement, onComplete) => {
        let currentProgress = 0;
        let isLoading = true;

        counterElement.textContent = '0%';

        const updateCounter = () => {
          if (!isLoading) return;

          const resources = performance.getEntriesByType('resource');
          const totalResources = resources.length || 1;
          const loadedResources = resources.filter((r) => r.responseEnd > 0).length;
          const realProgress = Math.round((loadedResources / totalResources) * 100);

          if (currentProgress < realProgress) {
            const increment = Math.max(1, Math.ceil((realProgress - currentProgress) / 5));
            currentProgress = Math.min(currentProgress + increment, realProgress);
          } else if (currentProgress < 95) {
            currentProgress = Math.min(currentProgress + 1, 95);
          }

          counterElement.textContent = `${currentProgress}%`;

          if (currentProgress < 100) {
            setTimeout(updateCounter, 50);
          }
        };

        updateCounter();

        await new Promise((resolve) => {
          if (document.readyState === 'complete') {
            resolve();
          } else {
            window.addEventListener('load', () => resolve(), { once: true });
          }
        });

        const finishCounter = () => {
          return new Promise((resolve) => {
            const finalUpdate = () => {
              if (currentProgress < 100) {
                currentProgress += 2;
                if (currentProgress > 100) currentProgress = 100;
                counterElement.textContent = `${currentProgress}%`;
                setTimeout(finalUpdate, 30);
              } else {
                isLoading = false;
                resolve();
              }
            };
            finalUpdate();
          });
        };

        await finishCounter();
        setTimeout(onComplete, 500);
      };

      const initMouseFollow = (cardsElement) => {
        let mouseX = 0;
        let mouseY = 0;
        let currentX = 0;
        let currentY = 0;
        let rafId = null;

        const lerp = (start, end, factor) => start + (end - start) * factor;

        const handleMouseMove = (e) => {
          mouseX = (e.clientX - window.innerWidth / 2) * 0.03;
          mouseY = (e.clientY - window.innerHeight / 2) * 0.03;
        };

        const animate = () => {
          currentX = lerp(currentX, mouseX, 0.1);
          currentY = lerp(currentY, mouseY, 0.1);
          gsap.set(cardsElement, { x: currentX, y: currentY });
          rafId = requestAnimationFrame(animate);
        };

        window.addEventListener('mousemove', handleMouseMove);
        rafId = requestAnimationFrame(animate);

        return () => {
          window.removeEventListener('mousemove', handleMouseMove);
          if (rafId !== null) cancelAnimationFrame(rafId);
        };
      };

      const animatePreloaderOut = (preloaderElement) => {
        return new Promise((resolve) => {
          const tl = gsap.timeline({
            onComplete: () => {
              preloaderElement.style.display = 'none';
              resolve();
            },
          });

          tl.to(preloaderElement, {
            opacity: 0,
            duration: 0.8,
            ease: 'power2.inOut',
          });

          const cards = preloaderElement.querySelector('.prealoader_cards');
          if (cards) {
            tl.to(
              cards,
              {
                scale: 0.9,
                duration: 0.8,
                ease: 'power2.inOut',
              },
              0
            );
          }
        });
      };

      const initPreloader = () => {
        if (!isFirstVisit()) {
          const preloaderElement = document.querySelector('.preloader_component');
          if (preloaderElement) {
            preloaderElement.style.display = 'none';
          }
          return;
        }

        const preloaderElement = document.querySelector('.preloader_component');
        const counterElement = document.querySelector('.prealoader_cards-loading-count');
        const cardsElement = document.querySelector('.prealoader_cards');

        if (!preloaderElement) return;

        preloaderElement.style.display = 'flex';
        gsap.set(preloaderElement, { opacity: 1 });

        let cleanupMouseFollow = null;
        if (cardsElement) {
          cleanupMouseFollow = initMouseFollow(cardsElement);
        }

        if (counterElement) {
          animateCounter(counterElement, async () => {
            if (cleanupMouseFollow) cleanupMouseFollow();
            await animatePreloaderOut(preloaderElement);
            markVisitComplete();
          });
        } else {
          window.addEventListener('load', async () => {
            if (cleanupMouseFollow) cleanupMouseFollow();
            await animatePreloaderOut(preloaderElement);
            markVisitComplete();
          });
        }
      };

      // Initialize preloader
      initPreloader();
    </script>
  </body>
</html>

